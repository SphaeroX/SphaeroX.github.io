<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fahrrad Pose Erkennung</title>
    <style>
        #video, #canvas {
            display: block;
            margin: 0 auto;
        }
        #angleDisplay {
            text-align: center;
            margin-top: 20px;
            font-size: 20px;
        }
        #controls {
            text-align: center;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Fahrrad Pose Erkennung</h1>
    <div id="controls">
        <label for="cameraSelect">Kamera auswählen:</label>
        <select id="cameraSelect"></select>
        <button id="resetButton">Reset</button>
    </div>
    <video id="video" width="640" height="480" autoplay></video>
    <canvas id="canvas" width="640" height="480"></canvas>
    <div id="angleDisplay">Winkel: --°</div>
    <div id="minMaxDisplay">Min Winkel: --° | Max Winkel: --°</div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const angleDisplay = document.getElementById('angleDisplay');
        const minMaxDisplay = document.getElementById('minMaxDisplay');
        const cameraSelect = document.getElementById('cameraSelect');
        const resetButton = document.getElementById('resetButton');

        let minAngle = Infinity;
        let maxAngle = -Infinity;

        // Kamera aktivieren
        async function setupCamera() {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === 'videoinput');

            videoDevices.forEach((device, index) => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.text = device.label || `Kamera ${index + 1}`;
                cameraSelect.appendChild(option);
            });

            cameraSelect.addEventListener('change', () => {
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                }
                startCamera(cameraSelect.value);
            });

            if (videoDevices.length > 0) {
                startCamera(videoDevices[0].deviceId);
            }
        }

        async function startCamera(deviceId) {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { deviceId: { exact: deviceId } }
            });
            video.srcObject = stream;
            return new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    resolve(video);
                };
            });
        }

        // PoseNet initialisieren und Posen erkennen
        async function detectPose() {
            const net = await posenet.load();
            while (true) {
                const pose = await net.estimateSinglePose(video, {
                    flipHorizontal: false
                });
                drawPose(pose);
                await tf.nextFrame();
            }
        }

        // Pose zeichnen und Winkel berechnen
        function drawPose(pose) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const keypoints = pose.keypoints;

            const ankle = keypoints.find(point => point.part === 'leftAnkle');
            const knee = keypoints.find(point => point.part === 'leftKnee');
            const hip = keypoints.find(point => point.part === 'leftHip');

            if (ankle && knee && hip) {
                drawPoint(ankle.position);
                drawPoint(knee.position);
                drawPoint(hip.position);

                drawLine(ankle.position, knee.position);
                drawLine(knee.position, hip.position);

                const angle = calculateAngle(ankle.position, knee.position, hip.position);
                angleDisplay.textContent = `Winkel: ${angle.toFixed(2)}°`;

                if (angle < minAngle) minAngle = angle;
                if (angle > maxAngle) maxAngle = angle;

                minMaxDisplay.textContent = `Min Winkel: ${minAngle.toFixed(2)}° | Max Winkel: ${maxAngle.toFixed(2)}°`;
            }
        }

        function drawPoint(position) {
            ctx.beginPath();
            ctx.arc(position.x, position.y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = 'red';
            ctx.fill();
        }

        function drawLine(start, end) {
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function calculateAngle(a, b, c) {
            const ab = { x: b.x - a.x, y: b.y - a.y };
            const bc = { x: c.x - b.x, y: c.y - b.y };

            const dotProduct = ab.x * bc.x + ab.y * bc.y;
            const magnitudeAB = Math.sqrt(ab.x * ab.x + ab.y * ab.y);
            const magnitudeBC = Math.sqrt(bc.x * bc.x + bc.y * bc.y);

            const angle = Math.acos(dotProduct / (magnitudeAB * magnitudeBC));
            return angle * (180 / Math.PI);
        }

        resetButton.addEventListener('click', () => {
            minAngle = Infinity;
            maxAngle = -Infinity;
            minMaxDisplay.textContent = `Min Winkel: --° | Max Winkel: --°`;
        });

        // Kamera einrichten und Pose-Erkennung starten
        setupCamera().then(detectPose);
    </script>
</body>
</html>
